using Microsoft.EntityFrameworkCore;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Threading;
using System.Threading.Tasks;

namespace Facet.Search.EFCore;

/// <summary>
/// EF Core extensions for executing facet aggregations efficiently.
/// </summary>
public static class FacetAggregationExtensions
{
    /// <summary>
    /// Executes a categorical facet aggregation and returns value -> count dictionary.
    /// </summary>
    /// <typeparam name="T">The entity type.</typeparam>
    /// <typeparam name="TKey">The facet key type.</typeparam>
    /// <param name="query">The queryable to aggregate.</param>
    /// <param name="keySelector">Expression to select the facet key.</param>
    /// <param name="limit">Maximum number of facet values to return.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>Dictionary of facet values to counts.</returns>
    public static async Task<Dictionary<TKey, int>> AggregateFacetAsync<T, TKey>(
        this IQueryable<T> query,
        Expression<Func<T, TKey>> keySelector,
        int? limit = null,
        CancellationToken cancellationToken = default)
        where TKey : notnull
    {
        var grouped = query
            .GroupBy(keySelector)
            .Select(g => new { Key = g.Key, Count = g.Count() })
            .OrderByDescending(x => x.Count);

        if (limit.HasValue)
        {
            var results = await grouped.Take(limit.Value).ToListAsync(cancellationToken);
            return results.ToDictionary(x => x.Key, x => x.Count);
        }
        else
        {
            var results = await grouped.ToListAsync(cancellationToken);
            return results.ToDictionary(x => x.Key, x => x.Count);
        }
    }

    /// <summary>
    /// Gets the minimum value for a numeric property asynchronously.
    /// </summary>
    public static async Task<TResult?> GetMinAsync<T, TResult>(
        this IQueryable<T> query,
        Expression<Func<T, TResult>> selector,
        CancellationToken cancellationToken = default)
        where TResult : struct
    {
        if (!await query.AnyAsync(cancellationToken))
            return null;

        return await query.MinAsync(selector, cancellationToken);
    }

    /// <summary>
    /// Gets the maximum value for a numeric property asynchronously.
    /// </summary>
    public static async Task<TResult?> GetMaxAsync<T, TResult>(
        this IQueryable<T> query,
        Expression<Func<T, TResult>> selector,
        CancellationToken cancellationToken = default)
        where TResult : struct
    {
        if (!await query.AnyAsync(cancellationToken))
            return null;

        return await query.MaxAsync(selector, cancellationToken);
    }

    /// <summary>
    /// Gets min and max values for a numeric property asynchronously.
    /// </summary>
    public static async Task<(TResult? Min, TResult? Max)> GetRangeAsync<T, TResult>(
        this IQueryable<T> query,
        Expression<Func<T, TResult>> selector,
        CancellationToken cancellationToken = default)
        where TResult : struct
    {
        if (!await query.AnyAsync(cancellationToken))
            return (null, null);

        var min = await query.MinAsync(selector, cancellationToken);
        var max = await query.MaxAsync(selector, cancellationToken);
        return (min, max);
    }

    /// <summary>
    /// Counts true and false values for a boolean property asynchronously.
    /// </summary>
    public static async Task<(int TrueCount, int FalseCount)> CountBooleanAsync<T>(
        this IQueryable<T> query,
        Expression<Func<T, bool>> selector,
        CancellationToken cancellationToken = default)
    {
        // Compile the expression to use in the Where clause
        var parameter = selector.Parameters[0];
        var notExpression = Expression.Not(selector.Body);
        var notSelector = Expression.Lambda<Func<T, bool>>(notExpression, parameter);

        var trueCount = await query.CountAsync(selector, cancellationToken);
        var falseCount = await query.CountAsync(notSelector, cancellationToken);

        return (trueCount, falseCount);
    }

    /// <summary>
    /// Asynchronously executes all facet aggregations and returns the results.
    /// This is the async equivalent of the generated GetFacetAggregations() method.
    /// </summary>
    /// <typeparam name="TEntity">The entity type being queried (e.g., Product).</typeparam>
    /// <typeparam name="TResults">The generated facet results type (e.g., ProductFacetResults).</typeparam>
    /// <param name="query">The IQueryable to aggregate.</param>
    /// <param name="cancellationToken">Optional cancellation token.</param>
    /// <returns>A populated TResults object with all facet aggregations computed asynchronously.</returns>
    /// <remarks>
    /// <para>
    /// This method works with the <c>*FacetResults</c> class generated by the Facet.Search source generator.
    /// It inspects the results class properties and automatically executes the appropriate database queries
    /// for each facet type (Categorical, Range, Boolean).
    /// </para>
    /// <para>
    /// All queries execute sequentially to respect Entity Framework Core's DbContext concurrency constraints.
    /// </para>
    /// <para><strong>Supported Facet Types:</strong></para>
    /// <list type="bullet">
    /// <item><description><strong>Categorical/Hierarchical:</strong> Dictionary&lt;string, int&gt; properties - Groups and counts distinct values</description></item>
    /// <item><description><strong>Range:</strong> Nullable Min/Max properties - Computes minimum and maximum values</description></item>
    /// <item><description><strong>Boolean:</strong> TrueCount/FalseCount properties - Counts true and false values</description></item>
    /// </list>
    /// </remarks>
    /// <example>
    /// <code>
    /// // Execute all aggregations
    /// var aggregations = await dbContext.Products
    ///     .GetFacetAggregationsAsync&lt;Product, ProductFacetResults&gt;();
    ///
    /// // Access categorical facets
    /// foreach (var (brand, count) in aggregations.Brand)
    ///     Console.WriteLine($"{brand}: {count}");
    ///
    /// // Access range facets
    /// Console.WriteLine($"Price: ${aggregations.PriceMin} - ${aggregations.PriceMax}");
    ///
    /// // Access boolean facets
    /// Console.WriteLine($"In stock: {aggregations.InStockTrueCount}");
    ///
    /// // Works with filtered queries
    /// var filter = new ProductSearchFilter { Category = ["Electronics"] };
    /// var filtered = await dbContext.Products
    ///     .ApplyFacetedSearch(filter)
    ///     .GetFacetAggregationsAsync&lt;Product, ProductFacetResults&gt;();
    /// </code>
    /// </example>
    public static async Task<TResults> GetFacetAggregationsAsync<TEntity, TResults>(
        this IQueryable<TEntity> query,
        CancellationToken cancellationToken = default)
        where TResults : class, new()
    {
        var results = new TResults();
        var resultsType = typeof(TResults);
        var entityType = typeof(TEntity);

        // Process each property in the results object sequentially
        foreach (var prop in resultsType.GetProperties())
        {
            var propName = prop.Name;
            var propType = prop.PropertyType;

            // Categorical/Hierarchical facets: Dictionary<string, int>
            if (propType.IsGenericType &&
                propType.GetGenericTypeDefinition() == typeof(Dictionary<,>) &&
                propType.GetGenericArguments()[0] == typeof(string) &&
                propType.GetGenericArguments()[1] == typeof(int))
            {
                // Find the corresponding entity property
                var entityProp = entityType.GetProperty(propName);
                if (entityProp != null && entityProp.PropertyType == typeof(string))
                {
                    var param = Expression.Parameter(entityType, "x");
                    var propAccess = Expression.Property(param, entityProp);
                    var lambda = Expression.Lambda<Func<TEntity, string>>(propAccess, param);

                    var dict = await query
                        .Where(Expression.Lambda<Func<TEntity, bool>>(
                            Expression.NotEqual(propAccess, Expression.Constant(null, typeof(string))),
                            param))
                        .GroupBy(lambda)
                        .Select(g => new { Key = g.Key, Count = g.Count() })
                        .OrderByDescending(x => x.Count)
                        .ToListAsync(cancellationToken);

                    prop.SetValue(results, dict.ToDictionary(x => x.Key, x => x.Count));
                }
            }
            // Range facets: Min/Max properties
            else if (propName.EndsWith("Min") || propName.EndsWith("Max"))
            {
                var baseName = propName.EndsWith("Min") ? propName.Substring(0, propName.Length - 3) : propName.Substring(0, propName.Length - 3);
                var entityProp = entityType.GetProperty(baseName);

                if (entityProp != null && propType == typeof(Nullable<>).MakeGenericType(entityProp.PropertyType))
                {
                    if (!await query.AnyAsync(cancellationToken))
                    {
                        prop.SetValue(results, null);
                        continue;
                    }

                    var param = Expression.Parameter(entityType, "x");
                    var propAccess = Expression.Property(param, entityProp);
                    var lambda = Expression.Lambda(propAccess, param);

                    var method = propName.EndsWith("Min") ? "MinAsync" : "MaxAsync";
                    var efMethod = typeof(EntityFrameworkQueryableExtensions)
                        .GetMethods()
                        .First(m => m.Name == method && m.GetParameters().Length == 3)
                        .MakeGenericMethod(entityType, entityProp.PropertyType);

                    var task = (Task)efMethod.Invoke(null, new object[] { query, lambda, cancellationToken })!;
                    await task;

                    var resultProp = task.GetType().GetProperty("Result");
                    prop.SetValue(results, resultProp!.GetValue(task));
                }
            }
            // Boolean facets: TrueCount/FalseCount properties
            else if ((propName.EndsWith("TrueCount") || propName.EndsWith("FalseCount")) && propType == typeof(int))
            {
                var baseName = propName.EndsWith("TrueCount")
                    ? propName.Substring(0, propName.Length - 9)
                    : propName.Substring(0, propName.Length - 10);
                var entityProp = entityType.GetProperty(baseName);

                if (entityProp != null && entityProp.PropertyType == typeof(bool))
                {
                    var param = Expression.Parameter(entityType, "x");
                    var propAccess = Expression.Property(param, entityProp);

                    Expression condition = propName.EndsWith("TrueCount")
                        ? propAccess
                        : Expression.Not(propAccess);

                    var lambda = Expression.Lambda<Func<TEntity, bool>>(condition, param);
                    var count = await query.CountAsync(lambda, cancellationToken);
                    prop.SetValue(results, count);
                }
            }
        }

        return results;
    }
}
