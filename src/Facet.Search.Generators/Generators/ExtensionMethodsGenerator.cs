using Facet.Search.Generators.Models;
using System.Linq;
using System.Text;

namespace Facet.Search.Generators;

/// <summary>
/// Generates extension methods for applying search filters to IQueryable.
/// </summary>
internal static class ExtensionMethodsGenerator
{
    public static string Generate(SearchableModel model)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Linq.Expressions;");
        sb.AppendLine();
        sb.AppendLine($"namespace {model.Namespace}.Search;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Extension methods for searching {model.ClassName}.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public static class {model.ClassName}SearchExtensions");
        sb.AppendLine("{");

        GenerateApplySearchMethod(sb, model);
        
        // Generate helper method for full-text property selectors if there are full-text properties
        if (!model.FullTextProperties.IsEmpty)
        {
            GenerateFullTextPropertySelectors(sb, model);
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static void GenerateApplySearchMethod(StringBuilder sb, SearchableModel model)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Applies faceted search filtering to a queryable of {model.ClassName}.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <remarks>");
        sb.AppendLine($"    /// Full-text search strategy: {model.FullTextStrategy}");
        sb.AppendLine("    /// All filters are translated to SQL and executed on the database server.");
        if (model.FullTextStrategy != "LinqContains" && model.FullTextStrategy != "ClientSide")
        {
            sb.AppendLine("    /// ");
            sb.AppendLine($"    /// To use native {model.FullTextStrategy} search, reference Facet.Search.EFCore and call:");
            sb.AppendLine($"    /// query.ApplyFullTextSearch(filter.SearchText, {model.ClassName}SearchExtensions.GetFullTextPropertySelectors());");
        }
        sb.AppendLine("    /// </remarks>");
        sb.AppendLine($"    public static System.Linq.IQueryable<{model.Namespace}.{model.ClassName}> ApplyFacetedSearch(");
        sb.AppendLine($"        this System.Linq.IQueryable<{model.Namespace}.{model.ClassName}> query,");
        sb.AppendLine($"        {model.FilterClassName} filter)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (filter == null)");
        sb.AppendLine("            return query;");
        sb.AppendLine();

        // Generate facet filters
        foreach (var facet in model.Facets)
            GenerateFacetFilter(sb, facet);

        // Generate full-text search based on strategy
        if (!model.FullTextProperties.IsEmpty)
        {
            GenerateFullTextSearch(sb, model);
        }

        // Generate sorting logic
        GenerateSortingLogic(sb, model);

        sb.AppendLine("        return query;");
        sb.AppendLine("    }");
    }

    private static void GenerateFullTextPropertySelectors(StringBuilder sb, SearchableModel model)
    {
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets the property selectors for full-text search fields.");
        sb.AppendLine("    /// Use with Facet.Search.EFCore's full-text search extensions for native database search.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <example>");
        sb.AppendLine("    /// <code>");
        sb.AppendLine($"    /// // Using SQL Server FREETEXT:");
        sb.AppendLine($"    /// query.ApplySqlServerFreeText(searchTerm, {model.ClassName}SearchExtensions.GetFullTextPropertySelectors());");
        sb.AppendLine("    /// ");
        sb.AppendLine($"    /// // Using PostgreSQL ILike:");
        sb.AppendLine($"    /// query.ApplyPostgreSqlFullText(searchTerm, {model.ClassName}SearchExtensions.GetFullTextPropertySelectors());");
        sb.AppendLine("    /// </code>");
        sb.AppendLine("    /// </example>");
        sb.AppendLine($"    public static Expression<Func<{model.Namespace}.{model.ClassName}, string?>>[] GetFullTextPropertySelectors()");
        sb.AppendLine("    {");
        sb.AppendLine($"        return new Expression<Func<{model.Namespace}.{model.ClassName}, string?>>[]");
        sb.AppendLine("        {");
        
        foreach (var p in model.FullTextProperties)
        {
            sb.AppendLine($"            x => x.{p.Name},");
        }
        
        sb.AppendLine("        };");
        sb.AppendLine("    }");
    }

    private static void GenerateFullTextSearch(StringBuilder sb, SearchableModel model)
    {
        sb.AppendLine("        // Full-text search");
        sb.AppendLine("        if (!string.IsNullOrWhiteSpace(filter.SearchText))");
        sb.AppendLine("        {");

        switch (model.FullTextStrategy)
        {
            case "SqlServerFreeText":
                GenerateSqlServerFreeTextSearch(sb, model);
                break;

            case "SqlServerContains":
                GenerateSqlServerContainsSearch(sb, model);
                break;

            case "EfLike":
                GenerateEfLikeSearch(sb, model);
                break;

            case "PostgreSqlFullText":
                GeneratePostgreSqlFullTextSearch(sb, model);
                break;

            case "ClientSide":
                GenerateClientSideSearch(sb, model);
                break;

            case "LinqContains":
            default:
                GenerateLinqContainsSearch(sb, model);
                break;
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void GenerateLinqContainsSearch(StringBuilder sb, SearchableModel model)
    {
        sb.AppendLine("            // Uses LINQ Contains() -> translates to SQL LIKE '%term%'");
        sb.AppendLine("            var searchTerm = filter.SearchText.ToLower();");
        sb.Append("            query = query.Where(x => ");

        var first = true;
        foreach (var p in model.FullTextProperties)
        {
            if (!first) sb.Append(" || ");
            GeneratePropertyContainsExpression(sb, p);
            first = false;
        }

        sb.AppendLine(");");
    }

    private static void GenerateEfLikeSearch(StringBuilder sb, SearchableModel model)
    {
        sb.AppendLine("            // Uses EF.Functions.Like() pattern matching");
        sb.AppendLine("            // For native Like, use: query.ApplyLikeSearch(filter.SearchText, GetFullTextPropertySelectors())");
        sb.AppendLine("            var searchTerm = filter.SearchText.ToLower();");
        sb.Append("            query = query.Where(x => ");

        var first = true;
        foreach (var p in model.FullTextProperties)
        {
            if (!first) sb.Append(" || ");
            GeneratePropertyContainsExpression(sb, p);
            first = false;
        }

        sb.AppendLine(");");
    }

    private static void GenerateSqlServerFreeTextSearch(StringBuilder sb, SearchableModel model)
    {
        sb.AppendLine("            // SQL Server FREETEXT search - requires FULLTEXT index on the column(s)");
        sb.AppendLine("            // For native FREETEXT, use: query.ApplySqlServerFreeText(filter.SearchText, GetFullTextPropertySelectors())");
        sb.AppendLine("            var searchTerm = filter.SearchText.ToLower();");
        sb.Append("            query = query.Where(x => ");

        var first = true;
        foreach (var p in model.FullTextProperties)
        {
            if (!first) sb.Append(" || ");
            GeneratePropertyContainsExpression(sb, p);
            first = false;
        }

        sb.AppendLine(");");
    }

    private static void GenerateSqlServerContainsSearch(StringBuilder sb, SearchableModel model)
    {
        sb.AppendLine("            // SQL Server CONTAINS search - requires FULLTEXT index");
        sb.AppendLine("            // For native CONTAINS, use: query.ApplySqlServerContains(filter.SearchText, GetFullTextPropertySelectors())");
        sb.AppendLine("            var searchTerm = filter.SearchText.ToLower();");
        sb.Append("            query = query.Where(x => ");

        var first = true;
        foreach (var p in model.FullTextProperties)
        {
            if (!first) sb.Append(" || ");
            GeneratePropertyContainsExpression(sb, p);
            first = false;
        }

        sb.AppendLine(");");
    }

    private static void GeneratePostgreSqlFullTextSearch(StringBuilder sb, SearchableModel model)
    {
        sb.AppendLine("            // PostgreSQL full-text search");
        sb.AppendLine("            // For native ILike, use: query.ApplyPostgreSqlFullText(filter.SearchText, GetFullTextPropertySelectors())");
        sb.AppendLine("            var searchTerm = filter.SearchText.ToLower();");
        sb.Append("            query = query.Where(x => ");

        var first = true;
        foreach (var p in model.FullTextProperties)
        {
            if (!first) sb.Append(" || ");
            GeneratePropertyContainsExpression(sb, p);
            first = false;
        }

        sb.AppendLine(");");
    }

    private static void GenerateClientSideSearch(StringBuilder sb, SearchableModel model)
    {
        sb.AppendLine("            // CLIENT-SIDE EVALUATION - Data is loaded into memory first!");
        sb.AppendLine("            // Warning: This can be slow for large datasets.");
        sb.AppendLine("            var searchTerm = filter.SearchText.ToLower();");
        sb.AppendLine("            var materializedQuery = query.AsEnumerable()");
        sb.Append("                .Where(x => ");

        var first = true;
        foreach (var p in model.FullTextProperties)
        {
            if (!first) sb.Append(" || ");
            sb.Append($"(x.{p.Name}?.ToLower().Contains(searchTerm) ?? false)");
            first = false;
        }

        sb.AppendLine(")");
        sb.AppendLine("                .AsQueryable();");
        sb.AppendLine("            query = materializedQuery;");
    }

    private static void GeneratePropertyContainsExpression(StringBuilder sb, PropertyInfo p)
    {
        switch (p.Behavior)
        {
            case "StartsWith":
                sb.Append($"(x.{p.Name} != null && x.{p.Name}.ToLower().StartsWith(searchTerm))");
                break;
            case "EndsWith":
                sb.Append($"(x.{p.Name} != null && x.{p.Name}.ToLower().EndsWith(searchTerm))");
                break;
            case "Exact":
                sb.Append($"(x.{p.Name} != null && x.{p.Name}.ToLower() == searchTerm)");
                break;
            case "Contains":
            default:
                sb.Append($"(x.{p.Name} != null && x.{p.Name}.ToLower().Contains(searchTerm))");
                break;
        }
    }

    private static void GenerateFacetFilter(StringBuilder sb, SearchFacetInfo facet)
    {
        // Use PropertyPath for navigation properties, PropertyName for regular properties
        var accessPath = facet.PropertyPath;

        switch (facet.FacetType)
        {
            case "Categorical":
            case "Hierarchical":
                sb.AppendLine($"        if (filter.{facet.PropertyName}?.Any() == true)");
                sb.AppendLine($"            query = query.Where(x => filter.{facet.PropertyName}.Contains(x.{accessPath}));");
                break;
            case "Range":
                sb.AppendLine($"        if (filter.Min{facet.PropertyName}.HasValue)");
                sb.AppendLine($"            query = query.Where(x => x.{accessPath} >= filter.Min{facet.PropertyName}.Value);");
                sb.AppendLine($"        if (filter.Max{facet.PropertyName}.HasValue)");
                sb.AppendLine($"            query = query.Where(x => x.{accessPath} <= filter.Max{facet.PropertyName}.Value);");
                break;
            case "Boolean":
                sb.AppendLine($"        if (filter.{facet.PropertyName}.HasValue)");
                sb.AppendLine($"            query = query.Where(x => x.{accessPath} == filter.{facet.PropertyName}.Value);");
                break;
            case "DateRange":
                sb.AppendLine($"        if (filter.{facet.PropertyName}From.HasValue)");
                sb.AppendLine($"            query = query.Where(x => x.{accessPath} >= filter.{facet.PropertyName}From.Value);");
                sb.AppendLine($"        if (filter.{facet.PropertyName}To.HasValue)");
                sb.AppendLine($"            query = query.Where(x => x.{accessPath} <= filter.{facet.PropertyName}To.Value);");
                break;
        }
        sb.AppendLine();
    }

    private static void GenerateSortingLogic(StringBuilder sb, SearchableModel model)
    {
        // Collect all sortable properties
        var sortableProperties = model.SearchableProperties
            .Where(p => p.Sortable)
            .Select(p => p.Name)
            .ToList();

        // All facet properties are also sortable
        foreach (var facet in model.Facets)
        {
            if (!sortableProperties.Contains(facet.PropertyName))
                sortableProperties.Add(facet.PropertyName);
        }

        if (sortableProperties.Count == 0)
            return;

        sb.AppendLine();
        sb.AppendLine("        // Apply sorting");
        sb.AppendLine("        if (!string.IsNullOrWhiteSpace(filter.SortBy))");
        sb.AppendLine("        {");
        sb.AppendLine("            query = filter.SortBy switch");
        sb.AppendLine("            {");

        foreach (var propName in sortableProperties)
        {
            sb.AppendLine($"                \"{propName}\" => filter.SortDescending ");
            sb.AppendLine($"                    ? query.OrderByDescending(x => x.{propName})");
            sb.AppendLine($"                    : query.OrderBy(x => x.{propName}),");
        }

        sb.AppendLine("                _ => query // Ignore invalid sort properties");
        sb.AppendLine("            };");
        sb.AppendLine("        }");
    }
}
