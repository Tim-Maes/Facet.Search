using Facet.Search.Generators.Models;
using System.Text;

namespace Facet.Search.Generators;

/// <summary>
/// Generates the filter class from a SearchableModel.
/// </summary>
internal static class FilterClassGenerator
{
    public static string Generate(SearchableModel model)
    {
        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"namespace {model.Namespace}.Search;");
        sb.AppendLine();

        // XML documentation
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Generated search filter for {model.ClassName}.");
        sb.AppendLine("/// </summary>");

        // Class declaration
        sb.AppendLine($"public partial class {model.FilterClassName}");
        sb.AppendLine("{");

        // Generate properties for each facet
        foreach (var facet in model.Facets)
        {
            GenerateFacetProperty(sb, facet);
        }

        // Generate full-text search property if any text properties exist
        if (model.FullTextProperties.Count > 0)
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Full-text search query.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public string? SearchText { get; set; }");
            sb.AppendLine();
        }

        // Close class
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateFacetProperty(StringBuilder sb, SearchFacetInfo facet)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Filter by {facet.DisplayName ?? facet.PropertyName}.");
        sb.AppendLine("    /// </summary>");

        switch (facet.FacetType)
        {
            case "Range":
                sb.AppendLine($"    public {facet.PropertyType}? Min{facet.PropertyName} {{ get; set; }}");
                sb.AppendLine();
                sb.AppendLine("    /// <summary>");
                sb.AppendLine($"    /// Maximum {facet.PropertyName} value.");
                sb.AppendLine("    /// </summary>");
                sb.AppendLine($"    public {facet.PropertyType}? Max{facet.PropertyName} {{ get; set; }}");
                break;

            case "DateRange":
                sb.AppendLine($"    public System.DateTime? {facet.PropertyName}From {{ get; set; }}");
                sb.AppendLine();
                sb.AppendLine("    /// <summary>");
                sb.AppendLine($"    /// End date for {facet.PropertyName} filter.");
                sb.AppendLine("    /// </summary>");
                sb.AppendLine($"    public System.DateTime? {facet.PropertyName}To {{ get; set; }}");
                break;

            case "Geo":
                sb.AppendLine($"    public double? {facet.PropertyName}Latitude {{ get; set; }}");
                sb.AppendLine();
                sb.AppendLine($"    public double? {facet.PropertyName}Longitude {{ get; set; }}");
                sb.AppendLine();
                sb.AppendLine($"    public double? {facet.PropertyName}RadiusKm {{ get; set; }}");
                break;

            case "Categorical":
            case "Hierarchical":
                sb.AppendLine($"    public string[]? {facet.PropertyName} {{ get; set; }}");
                break;

            case "Boolean":
                sb.AppendLine($"    public bool? {facet.PropertyName} {{ get; set; }}");
                break;

            default:
                sb.AppendLine($"    public {facet.PropertyType}? {facet.PropertyName} {{ get; set; }}");
                break;
        }

        sb.AppendLine();
    }
}
